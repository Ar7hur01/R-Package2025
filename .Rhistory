stack_shp_on_rast <- function(shp_file, raster_file, output_folder) {
library(terra)
shapefile_data <- vect(shp_file)
raster_data <- rast(raster_file)
shapefile_reproject <- project(shapefile_data, crs(raster_data))
extracted_values <- extract(raster_data, shapefile_reproject)
for (i in seq_along(colnames(extracted_values))) {
colnames(extracted_values)[i] <- paste0("Band_", i-1)
}
# Print renamed dataframe
print(colnames(extracted_values))
head(extracted_values)
shapefile_data <- cbind(shapefile_data, extracted_values[,-1]) # Remove the ID column to avoid duplication
head(shapefile_data)
file_name <- "insitu_reflectance.txt"
file_path <- file.path(output_folder, file_name)
write.table(
shapefile_data,
file = file_path,
append = FALSE,              # Append to the file after projection
row.names = FALSE,          # Do not write row numbers
col.names = TRUE,           # Include column headers
sep = "\t",                 # Use tab-delimited format
quote = FALSE,
)
}
stack_shp_on_rast("C:/Users/AD/Desktop/R_Package/Enkelboom/Enkelboom punte.shp",
"C:/Users/AD/Desktop/R_Package/08-01-25_enkelboom_stacked.tif",
"C:/Users/AD/Desktop/R_Package/Output")
# Load the required packages
library(randomForest)
library(terra)
library(raster)
install.packages("sp")
install.packages("sp")
# Function for training the Random Forest model
train_rf_model <- function(regression_input_path, response_var, ntree = 500, mtry = 3) {
# Load the dataset
regression_input <- read.table(regression_input_path, header = TRUE, sep = "\t")
# Exclude rows with NA values
regression_input <- na.omit(regression_input)
# Define the predictors and the response variable
predictors <- grep("^Band", colnames(regression_input), value = TRUE)
# Create a formula for the model
formula <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))
# Split the data into training and test sets (80% for training, 20% for testing)
set.seed(123) # For reproducibility
train_indices <- sample(1:nrow(regression_input), size = 0.8 * nrow(regression_input))
train_data <- regression_input[train_indices, ]
test_data <- regression_input[-train_indices, ]
# Train the Random Forest Regression model
rf_model <- randomForest(formula, data = train_data, ntree = ntree, mtry = mtry, importance = TRUE)
# Print model summary
print(rf_model)
# Predict on test data
predictions <- predict(rf_model, newdata = test_data)
# Calculate RMSE (Root Mean Squared Error)
actual <- test_data[[response_var]]
rmse <- sqrt(mean((actual - predictions)^2))
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
# Return the trained model
return(rf_model)
}
train_rf_model("C:/Users/AD/Desktop/R_Package/Output/insitu_reflectance.txt",
"in_situ")
# Function for training the Random Forest model
train_rf_model <- function(regression_input_path, response_var, ntree = 500, mtry = 3) {
# Load the dataset
regression_input <- read.table(regression_input_path, header = TRUE, sep = "\t")
# Exclude rows with NA values
regression_input <- na.omit(regression_input)
# Define the predictors and the response variable
predictors <- grep("^Band", colnames(regression_input), value = TRUE)
# Create a formula for the model
formula <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))
# Split the data into training and test sets (80% for training, 20% for testing)
set.seed(123) # For reproducibility
train_indices <- sample(1:nrow(regression_input), size = 0.8 * nrow(regression_input))
train_data <- regression_input[train_indices, ]
test_data <- regression_input[-train_indices, ]
# Train the Random Forest Regression model
rf_model <- randomForest(formula, data = train_data, ntree = ntree, mtry = mtry, importance = TRUE)
# Print model summary
print(rf_model)
# Predict on test data
predictions <- predict(rf_model, newdata = test_data)
# Calculate RMSE (Root Mean Squared Error)
actual <- test_data[[response_var]]
rmse <- sqrt(mean((actual - predictions)^2))
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
# Return the trained model
return(rf_model)
save(model, file = "my_model.RData")
}
#working without problems
train_rf_model("C:/Users/AD/Desktop/R_Package/Output/insitu_reflectance.txt",
"in_situ")
save(model, file = "C:/Users/AD/Desktop/R_Package/Output/my_model.RData")
save(rf_model, file = "C:/Users/AD/Desktop/R_Package/Output/my_model.RData")
# Return the trained model
return(rf_model)
# Function for training the Random Forest model
train_rf_model <- function(regression_input_path, response_var, ntree = 500, mtry = 3) {
# Load the dataset
regression_input <- read.table(regression_input_path, header = TRUE, sep = "\t")
# Exclude rows with NA values
regression_input <- na.omit(regression_input)
# Define the predictors and the response variable
predictors <- grep("^Band", colnames(regression_input), value = TRUE)
# Create a formula for the model
formula <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))
# Split the data into training and test sets (80% for training, 20% for testing)
set.seed(123) # For reproducibility
train_indices <- sample(1:nrow(regression_input), size = 0.8 * nrow(regression_input))
train_data <- regression_input[train_indices, ]
test_data <- regression_input[-train_indices, ]
# Train the Random Forest Regression model
rf_model <- randomForest(formula, data = train_data, ntree = ntree, mtry = mtry, importance = TRUE)
# Print model summary
print(rf_model)
# Predict on test data
predictions <- predict(rf_model, newdata = test_data)
# Calculate RMSE (Root Mean Squared Error)
actual <- test_data[[response_var]]
rmse <- sqrt(mean((actual - predictions)^2))
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
# Return the trained model
return(rf_model)
save(rf_model, file = "C:/Users/AD/Desktop/R_Package/Output/my_model.RData")
}
#working without problems
train_rf_model("C:/Users/AD/Desktop/R_Package/Output/insitu_reflectance.txt",
"in_situ")
regression_input_path <- "C:/Users/AD/Desktop/R_Package/Output/insitu_reflectance.txt"
# Function for training the Random Forest model
#train_rf_model <- function(regression_input_path, response_var, ntree = 500, mtry = 3) {
# Load the dataset
regression_input <- read.table(regression_input_path, header = TRUE, sep = "\t")
# Exclude rows with NA values
regression_input <- na.omit(regression_input)
# Define the predictors and the response variable
predictors <- grep("^Band", colnames(regression_input), value = TRUE)
head(predictors)
print(predictors)
# Create a formula for the model
formula <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))
response_var <- "in_situ"
# Create a formula for the model
formula <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))
# Split the data into training and test sets (80% for training, 20% for testing)
set.seed(123) # For reproducibility
train_indices <- sample(1:nrow(regression_input), size = 0.8 * nrow(regression_input))
train_data <- regression_input[train_indices, ]
test_data <- regression_input[-train_indices, ]
# Train the Random Forest Regression model
rf_model <- randomForest(formula, data = train_data, ntree = ntree, mtry = mtry, importance = TRUE)
# Train the Random Forest Regression model
rf_model <- randomForest(formula, data = train_data, ntree = 500, mtry = 3, importance = TRUE)
View(rf_model)
saveRDS(rf_model, file = "rf_model.rds")
readRDS("rf_model.rds")
getwd()
varImpPlot(rf_model)
partialPlot(rf_model, train_data, Band_1)  # Change 'Band_1' to your variable name
partialPlot(rf_model, train_data, Band_2)  # Change 'Band_2' to your variable name
partialPlot(rf_model, train_data, Band_3)  # Change 'Band_3' to your variable name
ggplot(pred_df, aes(x = Observed, y = Predicted)) +
geom_point(alpha = 0.6, color = "blue") +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "Predicted vs Observed", x = "Observed Values", y = "Predicted Values") +
theme_minimal()
install.packages("ggplot2")
library(ggplot2)
ggplot(pred_df, aes(x = Observed, y = Predicted)) +
geom_point(alpha = 0.6, color = "blue") +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "Predicted vs Observed", x = "Observed Values", y = "Predicted Values") +
theme_minimal()
ggplot(rf_model, aes(x = Observed, y = Predicted)) +
geom_point(alpha = 0.6, color = "blue") +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "Predicted vs Observed", x = "Observed Values", y = "Predicted Values") +
theme_minimal()
readRDS("rf_model.rds")
View(rf_model)
model <- "C:/Users/AD/Desktop/R_Package_24-01-25/ourPackage/R/rf_model.rds"
model <- readRDS(model)
View(model)
raster_path <- "C:/Users/AD/Desktop/R_Package/08-01-25_enkelboom_stacked.tif"
satellite_raster <- rast(raster_path)  # Use 'rast' from the terra package
# Extract pixel values (reflectance values) from the raster
reflectance_values <- as.data.frame(satellite_raster, xy = TRUE)
# Remove NA values from the reflectance data (if necessary)
reflectance_values <- na.omit(reflectance_values)
head(reflectance_values)
model <- "C:/Users/AD/Desktop/R_Package_24-01-25/ourPackage/R/rf_model.rds"
model <- readRDS(model)
# Apply the trained Random Forest model to the reflectance values (predict the response variable)
predictions <- predict(model, newdata = reflectance_values[, -c(1, 2)])  # Exclude x, y columns for prediction
for (i in seq_along(colnames(reflectance_values))) {
colnames(reflectance_values)[i] <- paste0("Band_", i)
}
View(reflectance_values)
for (i in seq_along(colnames(reflectance_values[,3:ncol(reflectance_values)]))) {
colnames(reflectance_values)[i] <- paste0("Band_", i)
}
View(reflectance_values)
for (i in seq_along(colnames(reflectance_values))) {
colnames(reflectance_values[,3:ncol(reflectance_values)])[i] <- paste0("Band_", i)
}
for (i in seq_along(colnames(reflectance_values[,3:ncol(reflectance_values)]))) {
colnames(reflectance_values[,3:ncol(reflectance_values)])[i] <- paste0("Band_", i)
}
View(reflectance_values)
# Remove NA values from the reflectance data (if necessary)
reflect_values <- na.omit(reflectance_values)
head(reflectance_values)
for (i in seq_along(colnames(reflect_values[,3:ncol(reflect_values)]))) {
colnames(reflect_values[,3:ncol(reflect_values)])[i] <- paste0("Band_", i)
}
View(reflect_values)
colnames(reflect_values)[3:ncol(reflect_values)] <- paste0("Band_", seq_along(3:ncol(reflect_values)))
print(reflect_values)
# Remove NA values from the reflectance data (if necessary)
reflect_values <- na.omit(reflectance_values)
colnames(reflect_values)[3:ncol(reflect_values)] <- paste0("Band_", seq_along(3:ncol(reflect_values)))
print(reflect_values)
# Remove NA values from the reflectance data (if necessary)
reflect_values <- na.omit(reflectance_values)
head(reflectance_values)
# Extract pixel values (reflectance values) from the raster
reflectance_values <- as.data.frame(satellite_raster, xy = TRUE)
head(reflectance_values))
head(reflectance_values)
colnames(reflectance_values)[3:ncol(reflectance_values)] <- paste0("Band_", seq_along(3:ncol(reflectance_values)))
print(reflect_values)
# Apply the trained Random Forest model to the reflectance values (predict the response variable)
predictions <- predict(model, newdata = reflectance_values[, -c(1, 2)])  # Exclude x, y columns for prediction
print(predictions)
# Convert the predictions into a raster format
predicted_raster <- satellite_raster
values(predicted_raster) <- predictions
# Plot the regression map (predicted values)
plot(predicted_raster, main = "Regression Map: Predicted Values")
satellite_raster <- rast(raster_path)  # Use 'rast' from the terra package
# Extract pixel values (reflectance values) from the raster
reflectance_values <- as.data.frame(satellite_raster, xy = TRUE)
head(reflectance_values)
# Example: Assuming your dataframe is named 'reflect_values'
for (i in 3:ncol(reflectance_values)) {
colnames(reflectance_values)[i] <- paste0("Band_", i - 2)  # Subtract 2 to start numbering from 1
}
# Check the updated column names
print(colnames(reflect_values))
# Check the updated column names
print(reflect_values)
# Extract pixel values (reflectance values) from the raster
reflectance_values <- as.data.frame(satellite_raster, xy = TRUE)
head(reflectance_values)
# Example: Assuming your dataframe is named 'reflect_values'
for (i in 3:ncol(reflectance_values)) {
colnames(reflectance_values)[i] <- paste0("Band_", i)  # Subtract 2 to start numbering from 1
}
# Check the updated column names
print(reflect_values)
# Example: Assuming your dataframe is named 'reflect_values'
for (i in 3:ncol(reflectance_values)) {
colnames(reflectance_values)[i] <- paste0("Band_", i+2)  # Subtract 2 to start numbering from 1
}
# Check the updated column names
print(reflect_values)
# Check the updated column names
head(reflect_values)
# Extract pixel values (reflectance values) from the raster
reflectance_values <- as.data.frame(satellite_raster, xy = TRUE)
head(reflectance_values)
# Example: Assuming your dataframe is named 'reflect_values'
for (i in 3:ncol(reflectance_values)) {
colnames(reflectance_values)[i] <- paste0("Band_", i+2)  # Subtract 2 to start numbering from 1
}
# Check the updated column names
head(reflect_values)
# Extract pixel values (reflectance values) from the raster
reflectance_values <- as.data.frame(satellite_raster, xy = TRUE)
head(reflectance_values)
# Check the updated column names
head(reflectance_values)
# Example: Assuming your dataframe is named 'reflect_values'
for (i in 3:ncol(reflectance_values)) {
colnames(reflectance_values)[i] <- paste0("Band_", i+2)  # Subtract 2 to start numbering from 1
}
# Check the updated column names
head(reflectance_values)
# Example: Assuming your dataframe is named 'reflect_values'
for (i in 3:ncol(reflectance_values)) {
colnames(reflectance_values)[i] <- paste0("Band_", i+2)  # Subtract 2 to start numbering from 1
}
# Check the updated column names
head(reflectance_values)
# Example: Assuming your dataframe is named 'reflect_values'
for (i in 3:ncol(reflectance_values)) {
colnames(reflectance_values)[i] <- paste0("Band_", i-2)  # Subtract 2 to start numbering from 1
}
# Check the updated column names
head(reflectance_values)
print(reflectance_values)
# Apply the trained Random Forest model to the reflectance values (predict the response variable)
predictions <- predict(model, newdata = reflectance_values[, -c(1, 2)])  # Exclude x, y columns for prediction
print(predictions)
# Convert the predictions into a raster format
predicted_raster <- satellite_raster
values(predicted_raster) <- predictions
# Plot the regression map (predicted values)
plot(predicted_raster, main = "Regression Map: Predicted Values")
# Save the regression map as a new .tiff file
writeRaster(predicted_raster, "C:/Users/AD/Desktop/R_Package/Output", format = "GTiff", overwrite = TRUE)
# Save the regression map as a new .tiff file
writeRaster(predicted_raster, "C:/Users/AD/Desktop/R_Package/Output", filetype = "GTiff", overwrite = TRUE)
# Save the regression map as a new .tiff file
writeRaster(predicted_raster, "C:/Users/AD/Desktop/R_Package/Output", overwrite = TRUE)
# Save the regression map as a new .tiff file
writeRaster(predicted_raster, "C:/Users/AD/Desktop/R_Package/Output", gdal = ".TIFF", overwrite = TRUE)
# Save the regression map as a new .tiff file
writeRaster(predicted_raster, "C:/Users/AD/Desktop/R_Package/Output", gdal=c("COMPRESS=NONE", "TFW=YES"), datatype='INT1U', overwrite = TRUE)
# Save the regression map as a new .tiff file
writeRaster(predicted_raster, "C:/Users/AD/Desktop/R_Package/Output/prediction.tiff", gdal=c("COMPRESS=NONE", "TFW=YES"), datatype='INT1U', overwrite = TRUE)
# Convert importance values to a SpatRaster
importance_raster <- rast(as.matrix(model))
# Save as a TIFF with floating-point precision
writeRaster(predicted_raster, "C:/Users/AD/Desktop/R_Package/Output/prediction.tif", datatype = "FLT4S", overwrite = TRUE)
load("C:/Users/AD/Desktop/R_Package_24-01-25/ourPackage/R/.RData")
library(usethis)
usethis::use_git()
usethis::use_github()
library(devtools)
devtools::document()
install.packages("roxygen2")
library(roxygen2)
## function 2 for training the Random Forest model
# Install necessary package if not already installed
if (!require(randomForest)) {install.packages("randomForest")}
if (!require(terra)) {install.packages("terra")}
if (!require(raster)) {install.packages("raster")}
# Load the required packages
library(randomForest)
library(terra)
library(raster)
#' @param regression_input_path
#' @param response_var
#' @param output_folder
#' @param ntree
#' @param mtry
#'
#' @returns
#' @export
#'
#' @examples
train_rf_model <- function(regression_input_path, response_var, output_folder, ntree = 500, mtry = 3) {
# Load the dataset
regression_input <- read.table(regression_input_path, header = TRUE, sep = "\t")
# Exclude rows with NA values
regression_input <- na.omit(regression_input)
# Define the predictors and the response variable
predictors <- grep("^Band", colnames(regression_input), value = TRUE)
head(predictors)
print(predictors)
# Create a formula for the model
formula <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))
# Split the data into training and test sets (80% for training, 20% for testing)
set.seed(123) # For reproducibility
train_indices <- sample(1:nrow(regression_input), size = 0.8 * nrow(regression_input))
train_data <- regression_input[train_indices, ]
test_data <- regression_input[-train_indices, ]
# Train the Random Forest Regression model
rf_model <- randomForest(formula, data = train_data, ntree = 500, mtry = 3, importance = TRUE)
# Print model summary
print(rf_model)
# Predict on test data
predictions <- predict(rf_model, newdata = test_data)
# Calculate RMSE (Root Mean Squared Error)
actual <- test_data[[response_var]]
rmse <- sqrt(mean((actual - predictions)^2))
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
# Return the trained model
return(rf_model)
file_path <- file.path(output_folder, "rf_model.rds")
saveRDS(rf_model, file_path)
}
devtools::document()
install.packages("rgdal")
devtools::document()
devtools::document()
stack_shp_on_rast <- function(shp_file, raster_file, output_folder) {
library(terra)
shapefile_data <- vect(shp_file)
raster_data <- rast(raster_file)
shapefile_reproject <- project(shapefile_data, crs(raster_data))
extracted_values <- extract(raster_data, shapefile_reproject)
for (i in seq_along(colnames(extracted_values))) {
colnames(extracted_values)[i] <- paste0("Band_", i-1)
}
# Print renamed dataframe
print(colnames(extracted_values))
head(extracted_values)
shapefile_data <- cbind(shapefile_data, extracted_values[,-1]) # Remove the ID column to avoid duplication
head(shapefile_data)
file_name <- "insitu_reflectance.txt"
file_path <- file.path(output_folder, file_name)
write.table(
shapefile_data,
file = file_path,
append = FALSE,              # Append to the file after projection
row.names = FALSE,          # Do not write row numbers
col.names = TRUE,           # Include column headers
sep = "\t",                 # Use tab-delimited format
quote = FALSE,
)
}
devtools::document()
#' @param regression_input_path
#' @param response_var
#' @param output_folder
#' @param ntree
#' @param mtry
#'
#' @returns
#' @export
#'
#' @examples
train_rf_model <- function(regression_input_path, response_var, output_folder, ntree = 500, mtry = 3) {
# Load the dataset
regression_input <- read.table(regression_input_path, header = TRUE, sep = "\t")
# Exclude rows with NA values
regression_input <- na.omit(regression_input)
# Define the predictors and the response variable
predictors <- grep("^Band", colnames(regression_input), value = TRUE)
head(predictors)
print(predictors)
# Create a formula for the model
formula <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))
# Split the data into training and test sets (80% for training, 20% for testing)
set.seed(123) # For reproducibility
train_indices <- sample(1:nrow(regression_input), size = 0.8 * nrow(regression_input))
train_data <- regression_input[train_indices, ]
test_data <- regression_input[-train_indices, ]
# Train the Random Forest Regression model
rf_model <- randomForest(formula, data = train_data, ntree = 500, mtry = 3, importance = TRUE)
# Print model summary
print(rf_model)
# Predict on test data
predictions <- predict(rf_model, newdata = test_data)
# Calculate RMSE (Root Mean Squared Error)
actual <- test_data[[response_var]]
rmse <- sqrt(mean((actual - predictions)^2))
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
# Return the trained model
return(rf_model)
file_path <- file.path(output_folder, "rf_model.rds")
saveRDS(rf_model, file_path)
}
# Function to apply the trained Random Forest model on new raster data
apply_rf_to_raster <- function(rf_model, raster_path, output_raster_path) {
# load the satellite-scene
satellite_raster <- rast(raster_path)  # Use 'rast' from the terra package
# Extract pixel values (reflectance values) from the raster
reflectance_values <- as.data.frame(satellite_raster, xy = TRUE)
# Remove NA values from the reflectance data (if necessary)
reflect_values <- na.omit(reflectance_values)
# Rename the columns of the reflectance data and exclude the x, y columns
for (i in 3:ncol(reflectance_values)) {
colnames(reflectance_values)[i] <- paste0("Band_", i-2)  # Subtract 2 to start numbering from 1
}
head(reflectance_values)
# Apply the trained Random Forest model to the reflectance values (predict the response variable)
predictions <- predict(model, newdata = reflectance_values[, -c(1, 2)])  # Exclude x, y columns for prediction
print(predictions)
# Convert the predictions into a raster format
predicted_raster <- satellite_raster
values(predicted_raster) <- predictions
# Plot the regression map (predicted values)
plot(predicted_raster, main = "Regression Map: Predicted Values")
# Save as a TIF with decimal numbers of predictes in-situ measurements
writeRaster(predicted_raster, "C:/Users/AD/Desktop/R_Package/Output/prediction.tif", datatype = "FLT4S", overwrite = TRUE)
}
devtools::document()
devtools::document()
# Print model summary
print(rf_model)
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
